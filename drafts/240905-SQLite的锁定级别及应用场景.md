# SQLite 的锁定级别及应用场景

在 SQLite 中，如果一个数据库已经被一个进程以写入模式打开，其他进程或线程尝试写入同一数据库时会遇到一些限制。SQLite 使用文件级锁定机制来协调不同进程对数据库文件的访问。这里是相关的一些关键点：

### 1. 锁定级别

SQLite 实现了几种不同的锁定级别：

- **共享锁（Shared Lock）**：当一个进程读取数据库时设置。多个进程可以同时持有共享锁。
- **互斥锁（Reserved Lock）**：当一个进程想要写入数据库时设置，表明有一个进程打算写入数据库。其他进程可以继续读取数据库，但不能写入。
- **待定锁（Pending Lock）**：这种锁是一个过渡状态，表明当前写入进程正在尝试升级到排他锁，而新的读操作不能开始。
- **排他锁（Exclusive Lock）**：当一个进程正在实际进行写入操作时设置。此时，其他进程既不能读取也不能写入数据库。

### 2. 写入冲突

- 如果一个数据库已经由一个进程以写入模式打开（即已经持有或等待互斥锁、排他锁），那么其他任何尝试写入该数据库的进程都会遭到阻塞，直到当前的写操作完成并释放了锁。
- 这种写入尝试通常会导致被阻塞的进程接收到一个错误，如 "database is locked"。阻塞的进程可以选择重试操作，直到它成功为止，或者根据设定的超时策略放弃。

### 3. 并发读取

- SQLite 允许多个进程同时读取数据库（如果没有进程正在尝试写入），因为它们只会申请共享锁。

### 4. 处理锁定错误

- 对于需要高并发写入的应用，经常需要在应用层面实现重试机制，或者改变数据库架构。例如，可以将数据先写入到临时的存储系统，然后由单一的后台服务进程将数据批量写入 SQLite。
- 另外，考虑数据库的设置和优化，比如增加超时时间（使用 `PRAGMA busy_timeout`），或者使用更高级的并发控制机制如 WAL（Write-Ahead Logging）模式。

总的来说，如果一个进程已经打开了 SQLite 数据库进行写操作，其他进程在没有适当的锁定控制和冲突处理机制的情况下，不能同时进行写操作。这需要通过适当的应用逻辑来管理，以避免数据损坏和性能问题。